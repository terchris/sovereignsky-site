{{/*
  Render a small network map for a single connection.

  Usage:
    {{< network-connection-map connection_id="havfrue" >}}

  Data:
    - site.Data.networks["networks"] (connections)
    - site.Data.networks["networks-places"] (places w/ geo)

  Notes:
    - Uses the connection's explicit route if present; otherwise generates a curved path
      between consecutive endpoint_place_ids for a visually nice schematic.
*/}}

  {{ $connectionId := .Get "connection_id" | default "" }}
  {{/* focusMode: "midpoint" (default), "norway" */}}
  {{ $focusMode := .Get "focusMode" | default "midpoint" }}
{{ if not $connectionId }}
  <p class="text-sm text-neutral-600 dark:text-neutral-300">Missing <code>connection_id</code> for <code>network-connection-map</code>.</p>
{{ else }}
  {{ $networksRoot := site.Data.networks | default dict }}
  {{ $connections := (index $networksRoot "networks") | default (slice) }}
  {{ $places := (index $networksRoot "networks-places") | default (slice) }}
  {{ $connection := dict }}
  {{ range $connections }}
    {{ if eq .connection_id $connectionId }}
      {{ $connection = . }}
    {{ end }}
  {{ end }}

  {{ if not (index $connection "connection_id") }}
    <p class="text-sm text-neutral-600 dark:text-neutral-300">Unknown connection: <code>{{ $connectionId }}</code></p>
  {{ else }}
    <div class="w-full rounded-xl border border-neutral-200 dark:border-neutral-800 overflow-hidden">
      <div id="network-connection-map-{{ $connectionId }}" class="w-full" style="height: 420px;"></div>
    </div>

    <script type="application/json" id="network-connection-map-places-{{ $connectionId }}">{{ $places | jsonify | safeHTML }}</script>
    <script type="application/json" id="network-connection-map-connection-{{ $connectionId }}">{{ $connection | jsonify | safeHTML }}</script>

    <script>
      (function () {
        if (typeof echarts === 'undefined') return;

        function readJsonScript(id, fallback) {
          var el = document.getElementById(id);
          if (!el) return fallback;
          try {
            var v = JSON.parse(el.textContent || 'null');
            if (typeof v === 'string') {
              try { return JSON.parse(v); } catch (e2) { return v; }
            }
            return v || fallback;
          } catch (e) {
            return fallback;
          }
        }

        var places = readJsonScript('network-connection-map-places-{{ $connectionId }}', []);
        var conn = readJsonScript('network-connection-map-connection-{{ $connectionId }}', null);
        if (!conn) return;

        var geoByPlaceId = {};
        (places || []).forEach(function (p) {
          var id = p && (p.identifier || p.place_id);
          var g = p && p.geo;
          if (!id || !g) return;
          if (typeof g.latitude !== 'number' || typeof g.longitude !== 'number') return;
          geoByPlaceId[id] = { lat: g.latitude, lng: g.longitude, name: p.name || id };
        });

        function stableHash01(str) {
          var s = String(str || '');
          var h = 2166136261;
          for (var i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i);
            h = (h * 16777619) >>> 0;
          }
          return (h % 1000000) / 1000000;
        }

        function generatePrettyRouteLngLat(a, b, id, categoryKey) {
          var ax = a.lng, ay = a.lat;
          var bx = b.lng, by = b.lat;
          var mx = (ax + bx) / 2;
          var my = (ay + by) / 2;
          var dx = bx - ax;
          var dy = by - ay;
          var dist = Math.sqrt(dx * dx + dy * dy) || 1;
          var nx = -dy / dist;
          var ny = dx / dist;

          var t = stableHash01(id);
          var sign = (t < 0.5) ? -1 : 1;
          var base = (categoryKey === 'subsea') ? 0.18 : (categoryKey === 'terrestrial' ? 0.10 : 0.08);
          var mag = dist * (base + (t * 0.08));
          mag = Math.min(mag, 8);

          var cx = mx + nx * mag * sign;
          var cy = my + ny * mag * sign;

          var n = Math.max(10, Math.min(28, Math.round(dist * 2)));
          var pts = [];
          for (var i = 0; i <= n; i++) {
            var u = i / n;
            var uu = 1 - u;
            var x = uu * uu * ax + 2 * uu * u * cx + u * u * bx;
            var y = uu * uu * ay + 2 * uu * u * cy + u * u * by;
            pts.push([x, y]); // [lng, lat]
          }
          return pts;
        }

        function buildRouteLngLat() {
          var mediumKey = conn.medium || 'subsea';
          if (Array.isArray(conn.route) && conn.route.length >= 2) {
            return conn.route.map(function (p) { return [p[1], p[0]]; }); // [lng, lat]
          }
          var eps = conn.endpoint_place_ids || [];
          if (!Array.isArray(eps) || eps.length < 2) return null;
          var out = [];
          for (var i = 0; i < eps.length - 1; i++) {
            var a = geoByPlaceId[eps[i]];
            var b = geoByPlaceId[eps[i + 1]];
            if (!a || !b) continue;
            var seg = generatePrettyRouteLngLat(a, b, (conn.connection_id || '') + ':' + eps[i] + '>' + eps[i + 1], mediumKey);
            if (seg && seg.length >= 2) {
              if (out.length) seg = seg.slice(1);
              out = out.concat(seg);
            }
          }
          return out.length >= 2 ? out : null;
        }

        var route = buildRouteLngLat();
        if (!route) return;

        var endpoints = (conn.endpoint_place_ids || []).map(function (id) { return geoByPlaceId[id]; }).filter(Boolean);
        var points = endpoints.map(function (p) {
          return { name: p.name, value: [p.lng, p.lat, 10] };
        });

        // Match /networks map styling: domestic is always green, international splits by medium
        var lineColor = (conn.scope === 'domestic')
          ? '#22c55e'
          : ((conn.medium === 'subsea') ? '#06b6d4' : (conn.medium === 'terrestrial' ? '#a855f7' : '#f59e0b'));
        var isPlanned = (conn.status === 'planned');
        var lineType = isPlanned ? 'dotted' : 'solid';
        var lineWidth = isPlanned ? 4 : 3;
        var lineOpacity = isPlanned ? 0.95 : 0.85;

        var el = document.getElementById('network-connection-map-{{ $connectionId }}');
        var chart = echarts.init(el, null, { renderer: 'svg' });

        function fetchJson(url) {
          return fetch(url).then(function (res) { if (!res.ok) throw new Error('HTTP ' + res.status); return res.json(); });
        }

        fetchJson('/data/world.json').then(function (geoJson) {
          echarts.registerMap('world', geoJson);

          // Detail pages: center between endpoints by default (more intuitive for long-haul links).
          // Keep a reasonable zoom so we don't end up with a "whole world" view.
          var focusMode = String({{ $focusMode | jsonify | safeJS }}) || 'midpoint';

          function computeBoundsCenterAndZoom(routeLngLat) {
            var minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
            routeLngLat.forEach(function (p) {
              if (!p || p.length < 2) return;
              var lng = p[0], lat = p[1];
              if (typeof lng !== 'number' || typeof lat !== 'number') return;
              minLng = Math.min(minLng, lng);
              maxLng = Math.max(maxLng, lng);
              minLat = Math.min(minLat, lat);
              maxLat = Math.max(maxLat, lat);
            });
            if (!isFinite(minLng)) return { center: [10, 65], zoom: 3 };

            var center = [(minLng + maxLng) / 2, (minLat + maxLat) / 2];
            var lngSpan = Math.max(1e-6, (maxLng - minLng));
            var latSpan = Math.max(1e-6, (maxLat - minLat));
            var span = Math.max(lngSpan, latSpan * 1.2);

            // Heuristic zoom, clamped: prefer a tighter view on detail pages.
            // Still tries to keep both endpoints visible, but avoids a "whole world" feel.
            var zoom = 360 / (span * 3.2);
            zoom = Math.max(2.8, Math.min(5.2, zoom));

            return { center: center, zoom: zoom };
          }

          var centerZoom = computeBoundsCenterAndZoom(route);
          var center = centerZoom.center;
          var zoom = centerZoom.zoom;
          if (focusMode === 'norway') {
            center = [10, 65];
            zoom = 3;
          }
          var isDark = document.documentElement.classList.contains('dark');

          chart.setOption({
            geo: {
              map: 'world',
              roam: true,
              zoom: zoom,
              center: center,
              scaleLimit: { min: 1, max: 20 },
              itemStyle: { areaColor: isDark ? '#0b1220' : '#f5f5f5', borderColor: isDark ? '#1f2937' : '#d4d4d4' },
              emphasis: { itemStyle: { areaColor: isDark ? '#111827' : '#e5e5e5' } }
            },
            tooltip: { trigger: 'item' },
            series: [
              {
                name: conn.connection_name,
                type: 'lines',
                coordinateSystem: 'geo',
                polyline: true,
                data: [{ coords: route }],
                lineStyle: { color: lineColor, width: lineWidth, type: lineType, opacity: lineOpacity }
              },
              {
                name: 'Endpoints',
                type: 'scatter',
                coordinateSystem: 'geo',
                data: points,
                symbolSize: 9,
                itemStyle: { color: '#0ea5e9' },
                label: { show: true, formatter: '{b}', position: 'right', color: isDark ? '#e5e7eb' : '#111827' }
              }
            ]
          });

          // ECharts SVG can initialize before the container has its final size (esp. in markdown layout).
          // Force a couple of resizes + observe size changes so the map fills the box correctly.
          function safeResize() {
            try { chart.resize(); } catch (e) {}
          }
          requestAnimationFrame(safeResize);
          setTimeout(safeResize, 50);
          setTimeout(safeResize, 250);
          if (typeof ResizeObserver !== 'undefined') {
            try {
              var ro = new ResizeObserver(function () { safeResize(); });
              ro.observe(el);
            } catch (e) {}
          } else {
            window.addEventListener('resize', safeResize);
          }
        }).catch(function () {});
      })();
    </script>
  {{ end }}
{{ end }}


